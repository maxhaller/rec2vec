import random
from typing import List

from tqdm import tqdm
from rec2vec.util.graph_loader import load_edges, load_nodes
from rec2vec.util.load_config import load_config
from rec2vec import logger


class Graph:
    """
    A Graph stores two dictionaries.
    - connections: a graph combining vertices (ids) and their edges (neighbors) <id, [neighbor1.id, neighbor2.id, ...]>
    - node_dict: a dictionary to transform ids used in the graph to the original ids (and vice-versa)

    A graph allows to build a deepwalk corpus using the function build_deepwalk_corpus().
    It generates a set of random walks that are generated by randomly traversing the graph.
    These walks can then be used to feed the Word2Vec model.
    """

    def __init__(self, config_path: str):

        logger.debug(f'initializing graph from config {config_path}')

        config = load_config(path=config_path)
        self._node_dict = load_nodes(config=config)
        self._connections = load_edges(config=config)
        self._make_graph_bidirectional()

    def get_node_dict(self) -> dict[str, dict[str, str]]:
        """
        Returns node dict, mapping original ids to unique ids.

        :return: mapping from original to unique ids
        """
        return self._node_dict

    def _get_nodes(self):
        """
        Gets a graph's vertices (nodes).

        :return: ids of all nodes in the graph
        """

        logger.trace(f'_get_nodes()')

        return self._connections.keys()

    def _get_neighbors(self, node: str) -> list[str]:
        """
        Returns the neighbors of a node. Neighbors are nodes that are connected with
        a node via an edge.

        :param node:    id of a vertex in the graph
        :return:        list of ids of node's neighbors
        """

        logger.trace(f'_get_neighbors({node})')

        return self._connections[node]

    def _set_neighbors(self, node: str, neighbors: list[str]) -> None:
        """
        Sets (and replaces) a node's neighbors.

        :param node:        id of a node in the graph
        :param neighbors:   ids of the node's neighbors
        :return:
        """

        logger.trace(f'_set_neighbors({node}, {neighbors})')

        self._connections[node] = neighbors

    def _make_graph_bidirectional(self) -> None:
        """
        The original graph could be unidirectional, meaning that relations
        are only stored in one of two nodes.
        E.g.    node1 -> node2
                node2

         This function makes sure that all edges are bidirectional.
         E.g.   node1 -> node2
                node2 -> node1

        :return:
        """
        logger.trace('_make_graph_bidirectional()')

        for n in self._get_nodes():
            for ref in self._get_neighbors(node=n):
                if n != ref:
                    self._get_neighbors(node=ref).append(n)

        # Remove loops: node1 -> [node1, node2] => node1 -> [node2]
        self._clean_graph()

    def _clean_graph(self) -> None:
        """
        Removes cycles in the whole graph and orders neighbors by their id.

        A cycle is a structure where a node is their own neighbor.
        E.g.    node1 -> [node1, node2]

        After executing this function, the relation won't have cycles.
        E.g.    node1 -> [node2]

        :return:
        """

        logger.trace('_clean_graph()')

        for n in self._get_nodes():
            self._set_neighbors(node=n,
                                neighbors=list(sorted(set([x for x in self._get_neighbors(node=n) if x is not n]))))

    def _random_walk(self, path_length: int, seed: int, alpha: float = 0, rand: random.Random = random.Random(),
                     start: str = None) -> list[str]:
        """
        Records the path of a random walk over the graph.

        :param path_length: number of steps taken in walk
        :param seed:        seed for random actions (not a fixed value, otherwise all walks are the same)
        :param alpha:       possibility of being reset to the start
        :param rand:        object to make random choices (by default: seed=0)
        :param start:       starting node
        :return:            random path over the graph as a list of visited vertices
        """

        logger.trace(f'_random_walk({path_length}, {seed}, {alpha}, {rand}, {start})')

        # Initialize seed
        rand.seed(a=seed)

        # Initialize starting position
        path = [start] if start else [rand.choice(seq=list(self._get_nodes()))]

        # Take steps as long as the path length is not reached
        while len(path) < path_length:
            current_node = path[-1]  # the last node of the path represents the current node
            if len(self._get_neighbors(node=current_node)) > 0:
                # Reset path with a chance of alpha, move to a neighbor otherwise
                if rand.random() >= alpha:
                    path.append(rand.choice(seq=list(self._get_neighbors(node=current_node))))
                else:
                    path.append(path[0])

            # Stop walk, vertex has no neighbors
            else:
                break

        return path

    def build_deepwalk_corpus(self, num_paths: int = 5, path_length: int = 10, alpha: float = 0,
                              rand: random.Random = random.Random(0)) -> list[list[str]]:
        """
        Records a series of random walks over the graph.

        :param num_paths:       number of paths to be recorded per node
        :param path_length:     number of steps taken in walk
        :param alpha:           possibility of being reset to the start
        :param rand:            object to make random choices (by default: seed=0)
        :return:                list of random paths
        """

        logger.trace(f'build_deepwalk_corpus({num_paths}, {path_length}, {alpha}, {rand})')

        walks = []
        nodes = list(self._get_nodes())

        for i in tqdm(range(num_paths)):
            rand.shuffle(nodes)
            for node in nodes:
                walks.append(self._random_walk(path_length=path_length, seed=i, rand=rand, alpha=alpha, start=node))

        return walks
